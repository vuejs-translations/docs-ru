# Входные параметры {#props}

> Эта страница предполагает, что вы уже прочитали [Основы компонентов](/guide/essentials/component-basics). Сначала прочитайте это, если вы новичок в работе с компонентами.

<div class="options-api">
  <VueSchoolLink href="https://vueschool.io/lessons/vue-3-reusable-components-with-props" title="Бесплатный урок про входные параметры"/>
</div>

## Объявление входных параметров {#props-declaration}

Компоненты Vue требуют явного объявления входных параметров, чтобы Vue знал, какие внешние входные параметры, переданы компоненту, следует рассматривать как обычные атрибуты (которые будут рассмотрены в [отдельном разделе](/guide/components/attrs)).

<div class="composition-api">

В SFC использующих `<script setup>`, входные параметры могут быть объявлены с помощью макроса `defineProps()`:

```vue
<script setup>
const props = defineProps(['foo'])

console.log(props.foo)
</script>
```

В компонентах не имеющих`<script setup>`, входные параметры объявляются с помощью [`props`](/api/options-state#props):

```js
export default {
  props: ['foo'],
  setup(props) {
    // setup() получает входной параметр в качестве первого аргумента.
    console.log(props.foo)
  }
}
```

Обратите внимание, что аргумент, передаваемый в `defineProps()`, совпадает со значением, предоставляемым `props`: один и тот же API _props_ разделяется между двумя стилями декларации.

</div>

<div class="options-api">

Входные параметры объявляются с помощью опции [`props`](/api/options-state#props):

```js
export default {
  props: ['foo'],
  created() {
    // входной парметр доступен в `this`
    console.log(this.foo)
  }
}
```

</div>

В дополнение к объявлению входных параметров с использованием массива строк, мы также можем использовать объектный синтаксис:

<div class="options-api">

```js
export default {
  props: {
    title: String,
    likes: Number
  }
}
```

</div>
<div class="composition-api">

```js
// С использованием <script setup>
defineProps({
  title: String,
  likes: Number
})
```

```js
// Без использования <script setup>
export default {
  props: {
    title: String,
    likes: Number
  }
}
```

</div>

Для каждого свойства в синтаксисе объявления объекта ключом является имя входного параметра, а значением должна быть функция-конструктор ожидаемого типа.

Это не только документирует ваш компонент, но и предупредит других разработчиков, использующих ваш компонент, в консоли браузера, если они передадут неверный тип. Более подробно [валидацию входных параметров](#prop-validation) мы рассмотрим далее на этой странице.

<div class="options-api">

См. также: [Типизирование входных параметров](/guide/typescript/options-api#typing-component-props) <sup class="vt-badge ts" />

</div>

<div class="composition-api">

Если вы используете TypeScript с `<script setup>`, можно также объявлять входные параметры с помощью аннотаций чистого типа:

```vue
<script setup lang="ts">
defineProps<{
  title?: string
  likes?: number
}>()
</script>
```

Подробнее: [Типизирование входных параметров](/guide/typescript/composition-api#typing-component-props) <sup class="vt-badge ts" />

</div>

<div class="composition-api">

## Деструктурирование реактивных свойств <sup class="vt-badge" data-text="3.5+" /> \*\* {#reactive-props-destructure}

Система реактивности Vue отслеживает использование состояния на основе доступа к свойствам. Например, когда вы обращаетесь к `props.foo` в вычисляемом геттере или наблюдателе, свойство `foo` отслеживается как зависимость.

И так, дан следующий код:

```js
const { foo } = defineProps(['foo'])

watchEffect(() => {
  // до версии 3.5 функция сработает только один раз
  // перезапускается при изменении свойства "foo" в версии 3.5+
  console.log(foo)
})
```

В версии 3.4 и ниже `foo` является фактической константой и никогда не изменится. В версии 3.5 и выше компилятор Vue автоматически добавляет `props.` когда код в одном и том же блоке `<script setup>` обращается к переменным, деструктурированным из `defineProps` несколько раз. Поэтому приведенный выше код становится эквивалентным следующему:

```js {5}
const props = defineProps(['foo'])

watchEffect(() => {
  // `foo` преобразуется компилятором в `props.foo`
  console.log(props.foo)
})
```

Кроме того, вы можете использовать собственный синтаксис JavaScript для объявления значений по умолчанию для свойств. Это особенно полезно при использовании объявления свойств на основе типов:

```ts
const { foo = 'hello' } = defineProps<{ foo?: string }>()
```

Если вы предпочитаете визуально отличать деструктурированные свойства от обычных переменных в вашей IDE, расширение Vue в VSCode предоставляет настройку, позволяющую включить инлайн-подсказки для деструктурированных реквизитов.

### Передача деструктурированных свойств в функции {#passing-destructured-props-into-functions}

Когда мы передаём деструктурированное свойство в функцию, например:

```js
const { foo } = defineProps(['foo'])

watch(foo, /* ... */)
```

Это не будет работать так, как ожидалось, потому что это эквивалентно `watch(props.foo, ...)` - мы передаем значение, а не реактивный источник данных в `watch`. На самом деле, компилятор Vue отлавливает такие случаи и выдает предупреждение.

Подобно тому, как мы можем наблюдать за обычным свойством с помощью `watch(() => props.foo, ...)`, мы можем наблюдать за деструктурированным свойством, обернув его в геттер.

```js
watch(() => foo, /* ... */)
```

Кроме того, это рекомендуемый подход, когда нам нужно передать деструктурированное свойство во внешнюю функцию, сохранив при этом реактивность:

```js
useComposable(() => foo)
```

Внешняя функция может вызвать геттер (или нормализовать его с помощью [toValue](/api/reactivity-utilities.html#tovalue)) когда ей нужно отследить изменения предоставленного свойства, например, в вычисляемом или наблюдающем геттере.

</div>

## Детали передачи входных параметров {#prop-passing-details}

### Именование входных параметров {#prop-name-casing}

Мы объявляем длинные имена свойств, используя camelCase, поскольку это позволяет избежать необходимости использовать кавычки при использовании их в качестве ключей свойств, а также позволяет нам ссылаться на них непосредственно в выражениях шаблона, поскольку они являются валидными идентификаторами JavaScript:

<div class="composition-api">

```js
defineProps({
  greetingMessage: String
})
```

</div>
<div class="options-api">

```js
export default {
  props: {
    greetingMessage: String
  }
}
```

</div>

```vue-html
<span>{{ greetingMessage }}</span>
```

Технически, вы также можете использовать camelCase при передаче входных параметров дочернему компоненту (за исключением [шаблонов DOM](/guide/essentials/component-basics#dom-template-parsing-caveats)). Тем не менее, общепринятым является использование kebab-case во всех случаях для согласования с атрибутами HTML:

```vue-html
<MyComponent greeting-message="hello" />
```

Мы используем [PascalCase для тегов компонентов](/guide/components/registration#component-name-casing), когда это возможно, потому что это улучшает читаемость шаблона, отличая компоненты Vue от собственных элементов. Однако практическая польза от использования camelCase при передаче входных параметров не так велика, поэтому мы предпочитаем следовать соглашениям каждого языка.

### Статические и динамические входные параметры {#static-vs-dynamic-props}

До сих пор вы встречали, что входные параметры передаются как статические значения, например:

```vue-html
<BlogPost title="Как изучить Vue" />
```

Вы также встречали входные параметры, присваивающие динамическое значение с помощью  `v-bind` или сокращения `:`, например:

```vue-html
<!-- Динамически присваиваем значение переменной -->
<BlogPost :title="post.title" />

<!-- Динамически присваиваем значение комплексного выражения -->
<BlogPost :title="post.title + ' by ' + post.author.name" />
```

### Передача значений различных типов {#passing-different-value-types}

В двух приведенных выше примерах мы передаем строковые значения, но _любой_ тип значения может быть передан во входной параметр.

#### Числа {#number}

```vue-html
<!-- Несмотря на то, что `42` статическое значение, нам нужен v-bind, -->
<!-- чтобы сообщить Vue, что это выражение JavaScript, а не строка.    -->
<BlogPost :likes="42" />

<!-- Динамическое присвоение значения переменной. -->
<BlogPost :likes="post.likes" />
```

#### Булевы значения {#boolean}

```vue-html
<!-- Указание входного параметра без значения будет означать `true`. -->
<BlogPost is-published />

<!-- Несмотря на то, что `false` статическое значение, нам нужен v-bind, -->
<!-- чтобы сообщить Vue, что это выражение JavaScript, а не строка.      -->
<BlogPost :is-published="false" />

<!-- Динамическое присвоение значения переменной. -->
<BlogPost :is-published="post.isPublished" />
```

#### Массивы {#array}

```vue-html
<!-- Несмотря на то, что указан статический массив, нам нужен v-bind, -->
<!-- чтобы сообщить Vue, что это выражение JavaScript, а не строка.   -->
<BlogPost :comment-ids="[234, 266, 273]" />

<!-- Динамическое присвоение значения переменной. -->
<BlogPost :comment-ids="post.commentIds" />
```

#### Объекты {#object}

```vue-html
<!-- Несмотря на то, что указан статический объект, нам нужен v-bind, -->
<!-- чтобы сообщить Vue, что это выражение JavaScript, а не строка.   -->
<BlogPost
  :author="{
    name: 'Veronica',
    company: 'Veridian Dynamics'
  }"
 />

<!-- Динамическое присвоение значения переменной. -->
<BlogPost :author="post.author" />
```

### Передача нескольких свойств с помощью объекта {#binding-multiple-properties-using-an-object}

Если хотите передать все свойства объекта в качестве входных параметров, то можно использовать [`v-bind` без аргументов](/guide/essentials/template-syntax#dynamically-binding-multiple-attributes) (`v-bind` вместо `:prop-name`). Например, для объекта `post`:

<div class="options-api">

```js
export default {
  data() {
    return {
      post: {
        id: 1,
        title: 'Как изучить Vue'
      }
    }
  }
}
```

</div>
<div class="composition-api">

```js
const post = {
  id: 1,
  title: 'Как изучить Vue'
}
```

</div>

Следующий шаблон:

```vue-html
<BlogPost v-bind="post" />
```

Будет аналогичен такой записи:

```vue-html
<BlogPost :id="post.id" :title="post.title" />
```

## Однонаправленный поток данных {#one-way-data-flow}

Все входные параметры образуют **одностороннюю привязку** между дочерним свойством и родительским: когда родительское свойство обновляется — оно будет передаваться дочернему, но не наоборот. Это предотвращает случайное изменение дочерними компонентами родительского состояния, что может затруднить понимание потока данных приложения.

Кроме того, каждый раз, когда обновляется родительский компонент, все входные параметры дочернего компонента будут обновлены актуальными значениями. Это означает, что **не должны** пытаться изменять входной параметр внутри дочернего компонента. Если это сделать, Vue отобразит предупреждение в консоли.

<div class="composition-api">

```js
const props = defineProps(['foo'])

// ❌ предупреждение, входные параметры доступны только для чтения!
props.foo = 'bar'
```

</div>
<div class="options-api">

```js
export default {
  props: ['foo'],
  created() {
    // ❌ предупреждение, входные параметры доступны только для чтения!
    this.foo = 'bar'
  }
}
```

</div>

Обычно встречаются два случая, когда возникает соблазн изменять входной параметр:

1. **Входной параметр используется для передачи начального значения; дочерний компонент хочет использовать его как локальное свойство данных в дальнейшем.** В этом случае лучше всего определить локальное свойство в данных, которое использует значение входного параметра в качестве начального:

   <div class="composition-api">

   ```js
   const props = defineProps(['initialCounter'])

   // counter использует только props.initialCounter в качестве начального значения;
   // он не будет получать будущие обновления входного параметра.
   const counter = ref(props.initialCounter)
   ```

   </div>
   <div class="options-api">

   ```js
   export default {
     props: ['initialCounter'],
     data() {
       return {
         // counter использует только this.initialCounter в качестве начального значения;
         // он не будет получать будущие обновления входного параметра.
         counter: this.initialCounter
       }
     }
   }
   ```

   </div>

2. **Входной параметр передаётся как необработанное значение, которое необходимо преобразовать.** В таком случае лучше всего объявить вычисляемое свойство с использованием входного параметра:

   <div class="composition-api">

   ```js
   const props = defineProps(['size'])

   // вычисляемое свойство автоматически обновится при изменении входного параметра
   const normalizedSize = computed(() => props.size.trim().toLowerCase())
   ```

   </div>
   <div class="options-api">

   ```js
   export default {
     props: ['size'],
     computed: {
       // вычисляемое свойство автоматически обновится при изменении входного параметра
       normalizedSize() {
         return this.size.trim().toLowerCase()
       }
     }
   }
   ```

   </div>

### Мутация объектов / массивов из входных параметров {#mutating-object-array-props}

Когда объекты и массивы передаются как входные параметры, дочерний компонент не может изменить привязку входного параметра, но он **сможет** изменить вложенные свойства объекта или массива. Это связано с тем, что в JavaScript объекты и массивы передаются по ссылке, и предотвращение таких мутаций для Vue неоправданно дорого.

Основным недостатком таких мутаций является то, что они позволяют дочернему компоненту влиять на родительское состояние способом, который не очевиден для родительского компонента, что может затруднить анализ потока данных в будущем. Для лучшей практики следует избегать таких мутаций, если только родительский и дочерний элементы не тесно связаны по замыслу. В большинстве случаев дочерний компонент должен [выдать событие](/guide/components/events.html), чтобы позволить родительскому элементу выполнить мутацию.

## Валидация входных параметров {#prop-validation}

Компоненты могут указывать требования к своим входным параметрам, такие как определение типа, которые уже видели выше. Если эти требования не выполнены — Vue предупредит сообщением в JavaScript-консоли браузера. Это особенно полезно при разработке компонента, который предназначен для использования другими.

Чтобы указать валидации входного параметра, вы можете предоставить в <span class="composition-api">`defineProps()`</span><span class="options-api">опцию `props`</span>, объект с валидациями для проверки значения, вместо массива строк. Например:

<div class="composition-api">

```js
defineProps({
  // Базовая проверка типов
  //  (`null` и `undefined` проходят проверку для любого типа)
  propA: Number,
  // Несколько допустимых типов
  propB: [String, Number],
  // Обязательное значение строкового типа
  propC: {
    type: String,
    required: true
  },
  // Обязательное, но нулевое значение строкового типа
  propD: {
    type: [String, null],
    required: true
  },
  // Число со значением по умолчанию
  propE: {
    type: Number,
    default: 100
  },
  // Объект со значением по умолчанию
  propF: {
    type: Object,
    // Для объектов или массивов значения по умолчанию
    // должны возвращаться из функции. Функция получает необработанные
    // входные параметры, полученные компонентом в качестве аргумента.
    default(rawProps) {
      return { message: 'привет' }
    }
  },
  // Пользовательская функция для валидации
  // полный перечень входных параметров передается в качестве 2-го аргумента в 3.4+
  propG: {
    validator(value, props) {
      // Значение должно соответствовать одной из этих строк
      return ['success', 'warning', 'danger'].includes(value)
    }
  },
  // Функция с значением по умолчанию
  propH: {
    type: Function,
    // В отличие от объекта или массива по умолчанию, это не фабричная функция — это функция, 
    // служащая в качестве значения по умолчанию
    default() {
      return 'Функция по умолчанию'
    }
  }
})
```

:::tip Совет
Код внутри аргумента `defineProps()` **не может получить доступ к другим переменным, объявленным в `<script setup>`** поскольку при компиляции все выражение перемещается во внешнюю область видимости функции.
:::

</div>
<div class="options-api">

```js
export default {
  props: {
    // Базовая проверка типов
    //  (`null` и `undefined` проходят проверку для любого типа)
    propA: Number,
    // Несколько допустимых типов
    propB: [String, Number],
    // Обязательное значение строкового типа
    propC: {
      type: String,
      required: true
    },
    // Обязательное, но нулевое значение строкового типа
    propD: {
      type: [String, null],
      required: true
    },
    // Число со значением по умолчанию
    propE: {
      type: Number,
      default: 100
    },
    // Объект со значением по умолчанию
    propF: {
      type: Object,
      // Для объектов или массивов значения по умолчанию
      // должны возвращаться из функции. Функция получает необработанные
      // входные параметры, полученные компонентом в качестве аргумента.
      default(rawProps) {
        return { message: 'hello' }
      }
    },
    // Пользовательская функция для валидации
    // полный перечень входных параметров передается в качестве 2-го аргумента в 3.4+
    propG: {
      validator(value, props) {
        // Значение должно соответствовать одной из этих строк
        return ['success', 'warning', 'danger'].includes(value)
      }
    },
    // Функция с значением по умолчанию
    propH: {
      type: Function,
      // В отличие от объекта или массива по умолчанию, это не фабричная функция — это функция, 
      // служащая в качестве значения по умолчанию
      default() {
        return 'Функция по умолчанию'
      }
    }
  }
}
```

</div>

Дополнительные сведения:

- Все входные параметры по умолчанию являются необязательными, если не указано `required: true`.

- Отсутствующий необязательный входной параметр, отличный от `Boolean` будет иметь значение `undefined`.

- Отсутствующий входной параметр `Boolean` будет приведен к `false`. Вы можете изменить это, задав для него значение `по умолчанию`. Например: `default: undefined`, чтобы он вел себя как не булево значение.

- Если указано значение `по умолчанию`, оно будет использоваться, если разрешенное значение входного параметра `undefined` — это включает в себя как отсутствие входного параметра, так и явное `undefined` значение.

Когда проверка свойства завершается неудачей, Vue выдает консольное предупреждение (если используется сборка для разработки).

<div class="composition-api">

Если вы используете [объявления свойств на основе типов](/api/sfc-script-setup#typescript-only-features) <sup class="vt-badge ts" />, Vue сделает все возможное, чтобы скомпилировать аннотации типов в эквивалентные объявления свойств во время выполнения. Например, `defineProps<{ msg: string }>` будет скомпилирован в `{ msg: { type: String, required: true }}`.

</div>
<div class="options-api">

:::tip Примечание
Обратите внимание, что входные параметры проверяются **до** создания экземпляра компонента, поэтому свойства экземпляра (например `data`, `computed`, и т.д.) не будут доступны в функциях `default` и `validator`.
:::

</div>

### Проверка типа во время выполнения {#runtime-type-checks}

Значением `type` может быть одним из следующих собственных конструкторов:

- `String`
- `Number`
- `Boolean`
- `Array`
- `Object`
- `Date`
- `Function`
- `Symbol`
- `Error`

Кроме того, `type` может быть пользовательским классом или функцией конструктора, и утверждение будет сделано с помощью проверки `instanceof`. Например, дан следующий класс:

```js
class Person {
  constructor(firstName, lastName) {
    this.firstName = firstName
    this.lastName = lastName
  }
}
```

Вы можете использовать его как тип входного параметра:

<div class="composition-api">

```js
defineProps({
  author: Person
})
```

</div>
<div class="options-api">

```js
export default {
  props: {
    author: Person
  }
}
```

</div>

Vue будет использовать `instanceof Person` для проверки того, действительно ли значение входного параметра `author` является экземпляром класса `Person`.

### Обнуляемый Тип {#nullable-type}

Если тип является обязательным, но допускает значение null, вы можете использовать синтаксис массива, который включает `null`:

<div class="composition-api">

```js
defineProps({
  id: {
    type: [String, null],
    required: true
  }
})
```

</div>
<div class="options-api">

```js
export default {
  props: {
    id: {
      type: [String, null],
      required: true
    }
  }
}
```

</div>

Обратите внимание, что если `type` просто равен `null` без использования синтаксиса массива, то будет разрешен любой тип.

## Булево преобразование {#boolean-casting}

Входные параметры с типом `Boolean` имеют специальные правила приведения, чтобы имитировать поведение собственных булевых атрибутов. Дан  `<MyComponent>` со следующим объявлением:

<div class="composition-api">

```js
defineProps({
  disabled: Boolean
})
```

</div>
<div class="options-api">

```js
export default {
  props: {
    disabled: Boolean
  }
}
```

</div>

Компонент можно использовать следующим образом:

```vue-html
<!-- эквивалентно :disabled="true" -->
<MyComponent disabled />

<!-- эквивалентно :disabled="false" -->
<MyComponent />
```

Когда входной параметр объявлен с использованием нескольких типов, правила приведения для `Boolean` также будут применяться. Однако есть нюанс - когда есть и `String`, и `Boolean`, то правило приведения для `Boolean` применяется только в том случае, если `Boolean` находится раньше, чем `String`:

<div class="composition-api">

```js
// disabled будет преобразован в true
defineProps({
  disabled: [Boolean, Number]
})

// disabled будет преобразован в true
defineProps({
  disabled: [Boolean, String]
})

// disabled будет преобразован в true
defineProps({
  disabled: [Number, Boolean]
})

// disabled будет разобран как пустая строка (disabled="")
defineProps({
  disabled: [String, Boolean]
})
```

</div>
<div class="options-api">

```js
// disabled будет преобразован в true
export default {
  props: {
    disabled: [Boolean, Number]
  }
}

// disabled будет преобразован в true
export default {
  props: {
    disabled: [Boolean, String]
  }
}

// disabled будет преобразован в true
export default {
  props: {
    disabled: [Number, Boolean]
  }
}

// disabled будет разобран как пустая строка (disabled="")
export default {
  props: {
    disabled: [String, Boolean]
  }
}
```

</div>
